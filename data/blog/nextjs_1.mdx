---
title: ✨ 路由篇 App Router
date: '2024-06-15'
tags: ['nextjs']
draft: false
summary: 本文将全面讲解 Next.js 基于文件系统的路由解决方案 App Router，介绍了用于定义页面的page.js、定义布局的layout.js、定义模板的template.js、定义加载界面的loading.js、定义错误处理的error.js、定义 404 页面的not-found.js。
---

## 前言

路由（Router）是 Next.js 应用的重要组成部分。在 Next.js 中，路由决定了一个页面如何渲染或者一个请求该如何返回。

Next.js 有两套路由解决方案，之前的方案称之为“Pages Router”，目前的方案称之为“App Router”，两套方案目前是兼容的，都可以在 Next.js 中使用。

从 v13.4 起，App Router 已成为默认的路由方案，新的 Next.js 项目建议使用 App Router。

## 1. Next.js 为什么升级到 App Router ？

- Pages Router 方式有一个弊端，那就是 pages 目录的所有 js 文件都会被当成路由文件，这就导致比如组件不能写在 pages 目录下，不符合开发者的使用习惯。（当然 Pages Router 还有很多其他的问题）
- 升级为新的 App Router 后，现在的目录结构类似于：

```javascript
src/
└── app
    ├── page.js
    ├── layout.js
    ├── template.js
    ├── loading.js
    ├── error.js
    └── not-found.js
    ├── about
    │   └── page.js
    └── more
        └── page.js
```

层级关系:

![image.pngs](http://blog.minouccc.online:9000/blog/app_router_1.png)

## 3. 使用 App Router

### 3.1 定义路由（Routes）

创建嵌套的路由，只需要创建嵌套的文件夹。例如，`app/dashboard/settings` 目录对应的路由地址就是 `/dashboard/settings`。

### 3.2 定义页面（Pages）

需要创建一个特殊的名为 `page.js` 的文件。

### 3.3 定义布局（Layouts）

定义一个布局，你需要新建一个名为 `layout.js` 的文件，该文件默认导出一个 React 组件，该组件应接收一个 `children` prop，表示子布局或子页面。

- 注意：布局是支持**嵌套**的

#### 根布局（Root Layout）

布局支持嵌套，最顶层的布局我们称之为根布局（Root Layout），也就是 `app/layout.js`。它会应用于所有的路由。除此之外，这个布局还有点特殊。

使用 `create-next-app` 默认创建的 `layout.js` 代码如下：

```javascript
// app/layout.js
import './globals.css'
import { Inter } from 'next/font/google'

const inter = Inter({ subsets: ['latin'] })

export const metadata = {
  title: 'Create Next App',
  description: 'Generated by create next app',
}

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  )
}
```

其中：

1.  `app` 目录必须包含根布局，也就是 `app/layout.js` 这个文件是必需的。
2.  根布局必须包含 `html` 和 `body`标签，其他布局不能包含这些标签。如果你要更改这些标签，不推荐直接修改，参考[《Metadata 篇》](xxx)。
3.  你可以使用[路由组](xxx)创建多个根布局。
4.  默认根布局是[服务端组件](xxx)，且不能设置为客户端组件。

### 3.4 定义模板（Templates）

模板类似于布局，它也会传入每个子布局或页面，但不会像布局那样维持状态。

某些情况下，模板会比布局更适合：

- 依赖于 `useEffect` 和 `useState` 的功能，比如记录页面访问数（维持状态就不会在路由切换时记录访问数了）、用户反馈表单（每次重新填写）等。
- 更改框架的默认行为，例如，布局内的 `Suspense` 只会在布局加载时展示一次 fallback UI，但使用模板时，fallback 会在每次路由切换时展示。

### 3.5 定义加载界面（Loading UI）

`loading.js` 的实现原理是将 `page.js` 和下面的 `children` 用 `<Suspense>` 包裹。因为 `page.js` 导出一个 async 函数，`Suspense` 得以捕获数据加载的 promise，从而实现了 loading 组件的关闭。

`dashboard` 目录下我们新建一个 `loading.js`。
`loading.js`的代码如下：

```javascript
// app/dashboard/loading.js
export default function DashboardLoading() {
  return <>Loading dashboard...</>
}
```

同级的 `page.js` 代码如下：

```javascript
// app/dashboard/page.js
async function getData() {
  await new Promise((resolve) => setTimeout(resolve, 3000))
  return {
    message: 'Hello, Dashboard!',
  }
}
export default async function DashboardPage(props) {
  const { message } = await getData()
  return <h1>{message}</h1>
}
```

不再需要其他的代码，loading 的效果就实现了。其关键在于 page.js导出了一个 async 函数。

当然实现 loading 效果，不一定非导出一个 async 函数。也可以借助 React 的 `use` 函数。现在我们在 `dashboard`下新建一个 `about`目录，在其中新建 `page.js`文件。

`/dashboard/about/page.js` 代码如下：

```javascript
// /dashboard/about/page.js
import { use } from 'react'

async function getData() {
  await new Promise((resolve) => setTimeout(resolve, 5000))
  return {
    message: 'Hello, About!',
  }
}

export default function Page() {
  const { message } = use(getData())
  return <h1>{message}</h1>
}
```

同样实现了 loading 效果。

### 3.6 定义错误处理（Error Handling）

其实现借助了 React 的 Error Boundary 功能。简单来说，就是给 `page.js` 和 `children` 包了一层 `ErrorBoundary`。

- **注意**：
  因为 Layout 和 Template 在 ErrorBoundary 外面，这说明错误边界不能捕获同级的 `layout.js` 或 `template.js` 中的错误。如果你想捕获特定布局或模板中的错误，那就需要在父级的 `error.js` 里进行捕获。
  如果已经到了顶层，比如根布局中的错误如何捕获呢？为了解决这个问题，Next.js 提供了 `global-error.js` 文件，使用时需要将其放在 `app` 目录下。

`global-error.js`示例代码如下：

```javascript
'use client'
// app/global-error.js
export default function GlobalError({ error, reset }) {
  return (
    <html>
      <body>
        <h2>Something went wrong!</h2>
        <button onClick={() => reset()}>Try again</button>
      </body>
    </html>
  )
}
```

注：`global-error.js` 用来处理根布局和根模板中的错误，`app/error.js` 建议还是要写的

### 3.7 定义 404 页面

`not-found.js` - 当该路由不存在的时候展示的内容。

关于 `app/not-found.js` 一定要说明一点的是，它只能由两种情况触发：

1.  当组件抛出了 notFound 函数的时候
1.  当路由地址不匹配的时候

所以 `app/not-found.js` 可以修改默认 404 页面的样式。但是，如果 `not-found.js`放到了任何子文件夹下，它只能由 `notFound`函数手动触发。比如这样：

```javascript
// /dashboard/blog/page.js
import { notFound } from 'next/navigation'

export default function Page() {
  notFound()
  return <></>
}
```

执行 notFound 函数时，会由最近的 not-found.js 来处理。但如果直接访问不存在的路由，则都是由 `app/not-found.js` 来处理。

对应到实际开发，当我们请求一个用户的数据时或是请求一篇文章的数据时，如果该数据不存在，就可以直接丢出 `notFound` 函数，渲染自定义的 `not-found.js` 界面。示例代码如下：

```javascript
// app/dashboard/blog/[id]/page.js
import { notFound } from 'next/navigation'

async function fetchUser(id) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}

export default async function Profile({ params }) {
  const user = await fetchUser(params.id)

  if (!user) {
    notFound()
  }

  // ...
}
```

## 参考链接

1.  [Routers - MDN Web Docs Glossary: Definitions of Web-related terms | MDN](https://developer.mozilla.org/en-US/docs/Glossary/Routers)
2.  [Building Your Application: Routing](https://nextjs.org/docs/app/building-your-application/routing)
3.  [Routing: Defining Routes](https://nextjs.org/docs/app/building-your-application/routing/defining-routes)
4.  [Routing: Pages and Layouts](https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts)
5.  [Routing: Loading UI and Streaming](https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming)
6.  [Routing: Error Handling](https://nextjs.org/docs/app/building-your-application/routing/error-handling)
7.  [File Conventions: not-found.js](https://nextjs.org/docs/app/api-reference/file-conventions/not-found)
8.  [Functions: notFound](https://nextjs.org/docs/app/api-reference/functions/not-found)
