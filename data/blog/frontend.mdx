---
title: 🚀 Frontend
date: '2023-08-15'
tags: ['frontend']
draft: false
summary:
---

## 1. AI

1. **泛知识**：比如问 `AI` 淘宝里面怎么注册一个店铺，可能还可以，但是问淘宝里面某个部门多少人，这种肯定回答不到的。因为它的知识都是泛知识。

2. **致幻**：`AI` 的回答是根据你的上下文推断出来的，推断出来的东西跟你现实的东西多多少少会有些误差。

   在这种情况下，可能就会导致我们正式应用的场景里面就不合适了。如自动驾驶系统可能在特定情况下做出错误的判断，生成的文本可能包含虚构的事实或不准确的信息。

   针对上面泛知识+幻觉，我们一般会使用 `RAG` 的解决方案。

   - **`RAG (Retrieval-Augmented Generation)`**：就是在你的大模型基础上外挂一个知识库。比如说你们公司有一些内部资料或规则，大模型有联网搜索的能力，但有些东西可能搜不到，就可以通过一些文档通过知识库挂载到大模型，大模型就会参考知识库来回答。

   - **`Agent`**：一个智能体。就是能自主执行任务。智能体体现，比如有时候我问一个问题，从纯粹的大语言模型里面，只能回答你内容，但其实我们更希望的就是对方有时候输入的一些关键词，或对方输入的一个过程内容。

     比如有一个抑郁症患者，`AI` 推导出意图之后，可以返回一家大众点评上的一个抑郁症诊所，或者开一些治疗方案，或者推一篇知乎的文章，类似这样推一些东西给他。完成这些动作的这个东西就叫智能体了。

     `Agent` 里面完成的动作在大语言模型以外，根据指令去叠加指向更多的功能这样一种能力。`Agent` 接受内容，结合你的知识库，返回一些非文字以外的内容。

     一般来说我们配一个 `Agent`，第一会挂一个知识库，第二会有一个 `prompt`，就是引导 `AI` 往哪个方向回答，回答太泛了也不好，就是大概面向哪个领域去回答。

     而前端在这个架构里面就是一个 `Agent` 交互的体现。`Agent` 是一个能力，我可能需要有个场景给到用户去用，前端给到的可能就是一个交互界面，相当于你要满足这个 `Agent` 的能力，它可能会有刚才说到的非文字以外的能力，可能是列表，图片，甚至是个小程序，你的页面就要满足这个 `Agent` 的能力。

3. **开发框架**：`Langchain` / `dify`

4. **模型**：

- `OpenAI模型`：`gpt`
- `Google模型`：`gemini`
- `Authropic模型`：`claude`
- `国产模型`：`Qwen` (阿里通义千问) / `GLM` (智谱) / `Baichuan` (百川) / `Yi` (零一) / `ERNIE` (百度文心一言) / `Deepseek` (深度求搜) / `Doubao` (字节豆包) / `Spark` (讯飞星火)
- `其他模型`：`nova` / `grok`

## 2. seo

- **seo 搜索**：seo 自然搜索，也称为非付费搜索，搜索结果页面中的排列顺序是由 Google 搜索算法决定的。
- **seo 优化**:
  - 小工具可以投稿 ruanyf 大佬的科技爱好者周刊，如果被推荐了，当天可以带来几百+ 用户访问。(尽早地 Launch 并且暴露你的产品及域名，也让搜索引擎收录你的域名，越早越好。)
  - 使用 GSC 及 SEO AI 辅助分析工具，确定流量来源。接入 GSC 可以看到搜索关键词来源。
  - 更新 Mata、H2、Image 等任何能利用的地方
    a. Meta 信息对搜索排名非常重要，你看到搜索结果时搜索引擎会展示关键字和 meta 信息匹配度。
    b. 标题用于 Google SEO 组织和阐释内容，每个标题都充当路线图，不要跨级使用，如 H1 -> H2,而不是 H1 -> H3。
    c. 把 Img 的 Alt Title 也都利用起来。
  - 为特定的设备、地区用户也做一些优化和兼容。确定你的用户在哪用你的产品，发现用移动端访问的很多，快速兼容移动端适配及使用体验。例如中途发现来了很多阿拉伯地区用户，看了下就跑了，流失很严重，分析下原来像阿拉伯那边是从右往左读的阅读习惯，再 fix 了一版。
  - 利用好 Google 的 People also search for。我发现搜 SEO tool 的时候，大多数人会搜 Free SEO tools。于是我在主页加上了"it's free" badge，用户搜索 Free xxx 的时候，它已经上升到第二了。当你不知道怎么来构建你的关键字和长尾词的时候，谷歌的 People also search for是很好的参考。
  - 提升网页的 DR 和增加 backlink。DR 也叫网域权威，一般来说你的域的"权限"越高越好。而从其他优质的网站获取外链是提高网站域名评分（权威）分数的唯一方法。
  - 提交站点地图。为了让谷歌搜索引擎知道你的站点爬取规则及路径，需要创建 robot.txt 和 sitemap.xml，并且尽可能多的收录页面。

## 3. 微前端

### 什么是微前端

可以简单理解为将一个大型的前端应用拆分成多个模块。每个模块可以由不同的团队进行管理，并自主选择框架，拥有自己的仓库，可以独立部署上线。

一般应用于中后台项目，架构大概就是左边是菜单栏，右边内容区域会显示对应内容。如果项目过大，菜单过多，项目的打包和部署就比较慢。

基座可以简单理解为一个容器，访问哪个模块就加载哪个部分的资源文件。

### 微前端的好处

- **团队自治**：一般团队都是按照业务去划分的。如果几个团队维护同一个项目，会有合并代码、上线时间冲突的问题。
- **兼容老项目**：跨技术栈，新模块可以使用新技术栈。

### 现有的微前端方案

1. **iframe**：每个子应用通过 iframe 标签嵌入到父应用中，具有天然隔离。

   - **缺点**：
     1. URL不同步：如果刷新页面，iframe中的页面路由会丢失（例如，HTML引入 Ant Design 的 iframe）。
     2. 上面的例子会有两个不同的 window 对象，全局上下文完全隔离，内存变量不共享。
     3. UI不同步：比如 Ant Design 的弹窗遮罩（灰色背景）不会覆盖整个屏幕。
     4. 每次子应用进入都是一次浏览器的上下文重建、资源重新加载的过程（即每次刷新都会重新创建 iframe 上下文），比较慢。

2. **single-spa**：最早的微前端框架，首先在基座中注册所有的子应用路由。当 URL 改变时就会进行匹配，匹配到哪个子应用就会去加载对应的子应用。

   - 相对于 iframe 实现方案，这个中的基座和各个子应用之间共享着一个全局上下文，并且不存在 URL 不同步和 UI 不同步的情况。
   - **缺点**：
     1. 没有实现 JS 隔离和 CSS 隔离。
     2. 需要修改大量的配置，包括基座和子应用，不能开箱即用。
   - 总结下来，使用还是需要一定成本。

3. **qiankun**：
   1. 基于 single-spa 封装的，提供了更加开箱即用的 API。
   2. 技术栈无关，也是继承 single-spa。
   3. HTML entry 的方式接入，像使用 iframe 一样简单（我们每个项目是不是有一个 HTML 文件，然后这个文件是不是有我们需要加载的 CSS 和 JS 文件？qiankun 怎么实现的呢？把子应用的 HTML 文件拉过来，然后从中读取我们需要的文件，再把子应用的对应文件拉过来）。
   4. 实现了 single-spa 不具备的样式隔离和 JS 隔离。
   5. 资源预加载：在浏览器空闲时间预加载未打开的微应用资源，加载打开速度更快。

### 基于 qiankun 的微前端实战

- **基座（主应用）**：负责集成所有的子应用，提供一个入口能够访问所需的子应用展示，尽量不写复杂的业务逻辑。
- **子应用**：根据不同业务划分的模块，每个子应用都打包成 UMD 模块的形式供基座加载（方便 qiankun 读取生命周期）。

## 4. webpack / vite 打包工具

### Webpack - 一种用于构建 JavaScript 应用程序的静态模块打包器

#### 配置文件

- **入口**：entry
- **输出**：output
- **模块**：module 配置 rule，rule 里写各种 loader
- **插件**：plugins
- **其他配置**：mode 模式，devtool（source-map）

#### 性能优化

关注两个点：

1. **怎么减少 webpack 的打包时间**：

   - 从 loader 角度说，影响打包效率首当其冲应该是 Babel，因为 Babel 会把代码转成 AST，AST 继续转变成新代码。项目越大，转换代码的工作越多，效率越低，所以可以优化检索范围。
     - 比如 include 只在 src 目录下，exclude 排除 node_modules。当然还可以将 Babel 编译过的文件缓存起来，下次编译的时候只编译更改的文件，这样可以减少打包时间。
   - 受 Node 单线程限制，webpack 也是单线程。当执行 loader 长时间编译任务很多，可能会导致等待的情况，所以可以开启插件 HappyPack，可以将 loader 同步执行转为并行，充分利用系统资源。
   - DllPlugin 可以提前将类库打包然后引入，这种方式可以减少打包类库次数，只有当类库更新才重新打包，也实现了将公共代码抽离成单独文件的方案（比如想统一打包的类库为 `vender: ['react']`）。
   - 一些小的优化点：
     - 比如别名配置，帮助 webpack 更快映射找到路径（resolve.alias）。
     - 比如某些文件你确定没有其他依赖，可以配置 webpack 不扫描这个文件。对于大型的类库有比较大作用，因为某些库发布时就已经预打包，这意味着它们将所有依赖项打包到一个文件或多个文件，无需构建工具再次打包，相当于依赖关系已经处理好了（module.noParse），比如 jQuery、lodash。
     - 比如 HMR 热模块替换，修改某个模块代码，只有这个模块需要重新打包编译。

2. **怎么减少 webpack 打包后的文件体积**：

   - 按需加载：平常开发 SPA 项目时，都会至少存在十几个以上的路由，这时候可以将每个路由打包成一个文件，按需加载。对于大型库比如 lodash 也可以。
   - Tree Shaking：删除项目中未引用的代码，webpack 4 生产是默认开启。
   - 代码分割：多入口文件如果都引用了同一份代码，我们希望只打包成一份，其他文件引入可以用 splitChunks。
   - 代码压缩：webpack 3 是通过一些插件压缩 JS，webpack 4 的话 production 默认开启，同时还可以去压缩 HTML、CSS 以及一些 log 打印。

3. **怎么优化代码的运行性能**：
   - 当配置了 splitChunks，可以设置浏览器在空闲时间加载后续要使用的资源。
   - Network cache：开发过程中可以对静态资源做缓存，浏览器第二次请求资源就快了。
   - PWA：给项目提供离线的体验。

### Vite - 新兴的构建工具，它相比 webpack 最大的特点就是快

Vite 在开发环境（TS JSX 会做编译）并不做打包，基于浏览器的 type 为 module 的 script 实现。

（Vite 在开发环境下就是起了一个做编译的服务器，根据请求的 URL 找到对应的模块做编译之后返回。）

当你请求 `index.html` 的时候，它会通过 AST 遍历，找到其中所有的 script：

编译是通过不同的插件实现：

- **esbuild 插件**：编译 TS 和 JS。
- **CSS 插件**：编译 CSS。

浏览器支持 ES Module 的 import，那如果 `node_modules` 下的依赖有用 CommonJS 模块规范的代码呢？

这种就需要提前做一些转换，把 CommonJS 转成 ESM。

还有一个问题，如果每个模块都是请求时编译，那像 `lodash-es` 这种包，它可是有几百个模块的 import 呢：

这样跑起来，一个 `node_modules` 下的包就有几百个请求，依赖多了以后，很容易就几千个请求。

所以我们要提前处理，不但要把 `node_modules` 下代码的 CommonJS 提前转成 ES Module，还有提前对这些包做一次打包，变成一个 ES Module 模块。

所以，Vite 加了一个预构建功能 **pre bundle**。

在启动完开发服务器的时候，就马上对 `node_modules` 下的代码做打包，这个也叫 **deps optimize**，依赖优化。

Vite 会在这些预打包的模块后加一个 query 字符串带上 hash，然后用 max-age 强缓存。

在 build 的时候，Vite 会用 Rollup 做打包，那不会导致开发时的代码和生产环境不一致么？

Dev 时跑的 Vite 插件：

Vite 插件是兼容 Rollup 插件的，这样在开发的时候，在生产环境打包的时候，都可以用同样的插件对代码做 transform 等处理。

在 dev 的时候，它实现了一个 `PluginContainer`，用和 Rollup 插件同样的参数来调用 Vite 插件，然后 build 的时候，可以把这些插件直接作为 Rollup 插件用。

## 5. 前端监控
