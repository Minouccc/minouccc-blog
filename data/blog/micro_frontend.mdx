---
title: 🛠️ 微前端
date: '2024-05-19'
tags: ['微前端']
draft: false
summary: 关于微前端分享。
---

## 微前端

### 什么是微前端

可以简单理解为将一个大型的前端应用拆分成多个模块。每个模块可以由不同的团队进行管理，并自主选择框架，拥有自己的仓库，可以独立部署上线。

一般应用于中后台项目，架构大概就是左边是菜单栏，右边内容区域会显示对应内容。如果项目过大，菜单过多，项目的打包和部署就比较慢。

基座可以简单理解为一个容器，访问哪个模块就加载哪个部分的资源文件。

### 微前端的好处

- **团队自治**：一般团队都是按照业务去划分的。如果几个团队维护同一个项目，会有合并代码、上线时间冲突的问题。
- **兼容老项目**：跨技术栈，新模块可以使用新技术栈。

### 现有的微前端方案

1. **iframe**：每个子应用通过 iframe 标签嵌入到父应用中，具有天然隔离。

   - **缺点**：
     1. URL不同步：如果刷新页面，iframe中的页面路由会丢失（例如，HTML引入 Ant Design 的 iframe）。
     2. 上面的例子会有两个不同的 window 对象，全局上下文完全隔离，内存变量不共享。
     3. UI不同步：比如 Ant Design 的弹窗遮罩（灰色背景）不会覆盖整个屏幕。
     4. 每次子应用进入都是一次浏览器的上下文重建、资源重新加载的过程（即每次刷新都会重新创建 iframe 上下文），比较慢。

2. **single-spa**：最早的微前端框架，首先在基座中注册所有的子应用路由。当 URL 改变时就会进行匹配，匹配到哪个子应用就会去加载对应的子应用。

   - 相对于 iframe 实现方案，这个中的基座和各个子应用之间共享着一个全局上下文，并且不存在 URL 不同步和 UI 不同步的情况。
   - **缺点**：
     1. 没有实现 JS 隔离和 CSS 隔离。
     2. 需要修改大量的配置，包括基座和子应用，不能开箱即用。
   - 总结下来，使用还是需要一定成本。

3. **qiankun**：
   1. 基于 single-spa 封装的，提供了更加开箱即用的 API。
   2. 技术栈无关，也是继承 single-spa。
   3. HTML entry 的方式接入，像使用 iframe 一样简单（我们每个项目是不是有一个 HTML 文件，然后这个文件是不是有我们需要加载的 CSS 和 JS 文件？qiankun 怎么实现的呢？把子应用的 HTML 文件拉过来，然后从中读取我们需要的文件，再把子应用的对应文件拉过来）。
   4. 实现了 single-spa 不具备的样式隔离和 JS 隔离。
   5. 资源预加载：在浏览器空闲时间预加载未打开的微应用资源，加载打开速度更快。

### 基于 qiankun 的微前端实战

- **基座（主应用）**：负责集成所有的子应用，提供一个入口能够访问所需的子应用展示，尽量不写复杂的业务逻辑。
- **子应用**：根据不同业务划分的模块，每个子应用都打包成 UMD 模块的形式供基座加载（方便 qiankun 读取生命周期）。
